import pytest
from pathlib import Path

from .._exceptions import IsengardConsistencyError
from .._runner import Runner

from .conftest import resolvify


def test_clean_single_output(tmp_path: Path, runner_factory, rule_factory):
    target_path = tmp_path / "target.txt"
    resolved_target = resolvify(target_path)
    runner: Runner = runner_factory(
        rules=[
            rule_factory(
                resolved_outputs=[resolved_target],
            ),
        ],
    )

    # Nothing to clean
    runner.clean(resolved_target)

    # Something to clean
    target_path.touch()
    runner.clean(resolved_target)
    assert not target_path.exists()


def test_clean_multiple_output(tmp_path: Path, runner_factory, rule_factory):
    one_path = tmp_path / "one.txt"
    two_path = tmp_path / "two.txt"
    three_path = tmp_path / "sub/three.txt"
    runner: Runner = runner_factory(
        rules=[
            rule_factory(
                fn=lambda outputs: None,
                resolved_outputs=[
                    resolvify(one_path),
                    resolvify(two_path),
                    resolvify(three_path),
                ],
            ),
        ],
    )

    # Nothing to clean
    runner.clean(resolvify(three_path))

    # Something to clean
    one_path.touch()
    two_path.touch()
    three_path.parent.mkdir()
    three_path.touch()
    runner.clean(resolvify(three_path))
    # Cleaning a target actually clean all target generated by the rule
    assert not one_path.exists()
    assert not two_path.exists()
    assert not three_path.exists()


def test_clean_cascade(tmp_path: Path, runner_factory, rule_factory):
    src_path = tmp_path / "foo.pyx"
    gen_path = tmp_path / "foo.c"
    obj_path = tmp_path / "foo.o"
    bin_path = tmp_path / "foo.exe"
    runner: Runner = runner_factory(
        rules=[
            rule_factory(
                resolved_outputs=[resolvify(gen_path)],
                resolved_inputs=[resolvify(src_path)],
            ),
            rule_factory(
                resolved_outputs=[resolvify(obj_path)],
                resolved_inputs=[resolvify(gen_path)],
            ),
            rule_factory(
                resolved_outputs=[resolvify(bin_path)],
                resolved_inputs=[resolvify(obj_path)],
            ),
        ],
        config={"flags": "--foo"},
    )

    src_path.touch()

    # Nothing to clean
    runner.clean(resolvify(bin_path))
    assert src_path.exists()
    assert not gen_path.exists()
    assert not obj_path.exists()
    assert not bin_path.exists()

    gen_path.touch()
    obj_path.touch()
    bin_path.touch()

    # Cleaning a rule doesn't clean the rule depending on it...
    runner.clean(resolvify(gen_path))
    assert src_path.exists()
    assert not gen_path.exists()
    assert obj_path.exists()
    assert bin_path.exists()

    gen_path.touch()

    # On the other hand, cleaning a rule also clean the rule it depends on
    runner.clean(resolvify(bin_path))
    assert src_path.exists()
    assert not gen_path.exists()
    assert not obj_path.exists()
    assert not bin_path.exists()


def test_clean_detect_recursion(tmp_path: Path, runner_factory, rule_factory):
    a_path = tmp_path / "a.txt"
    b_path = tmp_path / "b.txt"
    c_path = tmp_path / "c.txt"
    runner: Runner = runner_factory(
        rules=[
            rule_factory(
                resolved_outputs=[resolvify(a_path)],
                resolved_inputs=[resolvify(b_path)],
            ),
            rule_factory(
                resolved_outputs=[resolvify(b_path)],
                resolved_inputs=[resolvify(c_path)],
            ),
            rule_factory(
                resolved_outputs=[resolvify(c_path)],
                resolved_inputs=[resolvify(a_path)],
            ),
        ],
    )

    expected_err = "Recursion detection in rules rule-a.txt# -> rule-b.txt# -> rule-c.txt#"
    with pytest.raises(IsengardConsistencyError, match=expected_err):
        runner.clean(resolvify(a_path))
