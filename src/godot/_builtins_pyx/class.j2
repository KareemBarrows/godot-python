{%- from '_builtins_pyx/constructor.j2' import render_constructor with context -%}
{%- from '_builtins_pyx/gdapi.j2' import render_gdapi with context -%}

{% macro render_spec(spec) -%}

{{ render_gdapi(spec) }}

@cython.freelist(8)
@cython.final
cdef class {{ spec.name }}:
{# TODO: I guess only Nil has no size, so remove it and only use None ? #}
{% if spec.size %}
    # Constructors
    {{ render_constructor(spec) | indent }}

    @staticmethod
    cdef inline {{ spec.name }} new():
        # Call to __new__ bypasses __init__ constructor
        cdef {{ spec.name }} ret = {{ spec.name }}.__new__({{ spec.name }})
        __{{ spec.name }}_constructor_0(ret._gd_data, NULL)
        return ret
{% endif %}

{% if spec.has_destructor %}
    # Destructor
    def __dealloc__({{ spec.name }} self):
        # /!\ if `__cinit__` is skipped, `_gd_data` must be initialized by
        # hand otherwise we will get a segfault here
        __{{ spec.name }}_destructor(self._gd_data)
{% else %}
    # Destructor not needed
{% endif %}

    def __repr__(self):
        # TODO: finish me...
        # gdapi.variant_stringify(&self._gd_data)
        return "<{{ spec.name }}>"

{% if spec.constants %}
    # Constants

{% endif %}
{% for c in spec.constants %}
    # {{ c.name }} = {{ c.value }}
{% endfor %}

{% if spec.members %}
    # Members
{% endif %}
{% for m in spec.members %}
    @property
    def {{ m.name }}(self) -> {{ m.type.py_type }}:
{%   if m.offset is not none %}
{%     if m.type.is_scalar %}
        return (<{{ m.type.c_type }}*>(&self._gd_data[{{ m.offset }}]))[0]
{#   TODO: ensure m.type doesn't need a destructor #}
{%     else %}
{#      TODO: Find a way to avoid this copy ? #}
        cdef {{ m.type.py_type }} ret = {{ m.type.py_type }}.__new__()  # Skips __init__()
        ret._gd_data = self._gd_data
        return ret
{%     endif %}
    @{{ m.name }}.setter
    def {{ m.name }}(self, {{ m.type.py_type }} value) -> None:
{%     if m.type.is_scalar %}
        (<{{ m.type.c_type }}*>(&self._gd_data[{{ m.offset }}]))[0] = value
{#   TODO: ensure m.type doesn't need a destructor #}
{%     else %}
        self._gd_data = value._gd_data
{%     endif %}
{%   else %}
        # TODO: support properties !
        raise NotImplementedError
{%   endif %}
{% endfor %}

{% if spec.methods %}
    # Methods
{% endif %}
{% for m in spec.methods %}
    def {{ m.name }}(
        self,
{% for arg in m.arguments %}
        {{ arg.name }},
{% endfor %}
    ):
        raise NotImplemented
{% endfor %}

{%- endmacro %}
