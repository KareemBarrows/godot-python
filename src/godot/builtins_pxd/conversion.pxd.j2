{% macro render_all_conversions(builtin) -%}
cdef bint gd_variant_supports_py_type(object pytype)
cdef object gd_to_py_type(GDNativeVariantType gdtype)
cdef GDNativeVariantType py_to_gd_type(object pytype)
cdef object gd_variant_steal_into_pyobj(const gd_variant_t *gdvar)
cdef object gd_variant_copy_into_pyobj(const gd_variant_t *gdvar)
cdef bint gd_variant_steal_from_pyobj(object pyobj, gd_variant_t *gdvar)


cdef str _ENSURE_IS_GDANY_ERR_MSG
cdef str _ENSURE_IS_GDSTRING_ERR_MSG
cdef str _ENSURE_IS_NODEPATH_ERR_MSG


cdef inline gd_variant_t ensure_is_gdany_and_borrow_ref(object pyobj):
    """
    /!\ ensure_is_gdany_and_borrow_ref stole the reference from pyobj !
    Most of the time this is more like sharing: the variant object is only
    use in the body of the function that called `ensure_is_gdany_and_borrow_ref`,
    then it is discarded without using it destructor (hence pyobj is not
    affected by this steal)
    """
    cdef gd_variant_t ret
    if not gd_variant_steal_from_pyobj(pyobj, &ret):
        raise TypeError(_ENSURE_IS_GDANY_ERR_MSG.format(repr(pyobj)))
    return ret


cdef inline GDString ensure_is_gdstring(object gdstring_or_pystr):
    cdef GDString gdstring_converted
    try:
        return <GDString?>gdstring_or_pystr
    except TypeError:
        try:
            return GDString(gdstring_or_pystr)
        except TypeError:
            raise TypeError(_ENSURE_IS_GDSTRING_ERR_MSG.format(repr(gdstring_or_pystr)))


cdef inline NodePath ensure_is_nodepath(object nodepath_or_pystr):
    cdef NodePath NodePath_converted
    try:
        return <NodePath?>nodepath_or_pystr
    except TypeError:
        try:
            return NodePath(nodepath_or_pystr)
        except TypeError:
            raise TypeError(_ENSURE_IS_NODEPATH_ERR_MSG.format(repr(nodepath_or_pystr)))
{% endmacro %}
