{%- from 'builtins_pyx/constructor.pxi.j2' import render_constructors with context -%}


{#########################################################################
 # Render constant
 #########################################################################}


{% macro render_constant(spec, c) %}
{%   if c.type.is_scalar %}
{{ c.name }}: {{ c.type.py_type }} = {{ c.value }}
{%   else %}
@property
def {{ c.name }}(self) -> {{ c.type.py_type }}:
    return {{ c.value }}
{%   endif %}
{% endmacro %}


{#########################################################################
 # Render transparent builtin scalar property
 #########################################################################}


{% macro render_transparent_builtin_scalar_property(m, name_prefix, access_prefix) -%}
@property
def {{ name_prefix }}{{ m.name }}(self) -> {{ m.type.py_type }}:
    return {{ access_prefix }}.{{ m.name }}
@{{ name_prefix }}{{ m.name }}.setter
def {{ name_prefix }}{{ m.name }}(self, {{ m.type.cy_type }} val):
    {{ access_prefix }}.{{ m.name }} = val
{% endmacro %}


{#########################################################################
 # Render transparent builtin subtype properties
 #########################################################################}


{% macro render_transparent_builtin_subtype_properties(m, name_prefix, access_prefix) -%}
{% for subm in m.type.builtin_spec.c_struct_members %}
{%   if subm.is_in_struct %}
{%     if subm.type.is_scalar %}
{{ render_transparent_builtin_scalar_property(subm, name_prefix, access_prefix) }}
{%     else %}
{{ render_transparent_builtin_subtype_properties(subm, "{}_{}".format(name_prefix, subm.name), "{}.{}".format(access_prefix, subm.name)) }}
{%     endif %}
{%   endif %}
{% endfor %}
{% endmacro %}


{#########################################################################
 # Render member
 #########################################################################}


{% macro render_member(spec, m) %}

{% if not m.is_in_struct %}
{# Property unrelated to the builtin internal structure, must use Godot API method to access it #}

{%   if m.type.is_scalar %}

{# Scalar type accessed by property (unused in extension_api.json afaik) #}
@property
def {{ m.name }}(self) -> {{ m.type.py_type }}:
    cdef {{ m.type.c_type }} r_value
    __{{ spec.name }}_get_{{ m.name }}(&self._gd_data, &r_value)
    return r_value
@{{ m.name }}.setter
def {{ m.name }}(self, {{ m.type.cy_type }} val):
    __{{ spec.name }}_set_{{ m.name }}(&self._gd_data, &val)

{%   else %}

{# Builtin type in the C structure (i.e. `Rect2i.end`) #}
@property
def {{ m.name }}(self) -> {{ m.type.py_type }}:
    # Call to __new__ bypasses __init__ constructor
    cdef {{ m.type.cy_type }} ret = {{ m.type.cy_type }}.__new__({{ m.type.cy_type }})
    __{{ spec.name }}_get_{{ m.name }}(&self._gd_data, &ret._gd_data)
    return ret
@{{ m.name }}.setter
def {{ m.name }}(self, {{ m.type.cy_type }} val):
    __{{ spec.name }}_set_{{ m.name }}(&self._gd_data, &val._gd_data)
{%   endif %}

{% else %}
{# Property that is contains in the builtin C structure #}

{%   if m.type.is_scalar %}

{# Scalar type in the C structure (i.e. `Vector2.x`) #}
{{ render_transparent_builtin_scalar_property(m, "", "self._gd_data") }}

{%   else %}

{# Builtin type in the C structure (i.e. `Rect2.position` with position being a `Vector2`) #}
{# In GDScript doing `rect2.position.x = 42` modifies `rect2`, that means `rect2.position` #}
{# is a proxy object on the content of `rect2`, this is cumbersome to do in Python (and make #}
{# thing slower) so we replace this by property on the subtype members: `rect2.position_x` #}
{{ render_transparent_builtin_subtype_properties(m, "{}_".format(m.name), "self._gd_data.{}".format(m.name)) }}

{# Also expose the member, but as a functions so it's clearer this works on copies #}
{%     for subm in m.type.builtin_spec.c_struct_members %}
def get_{{ m.name }}(self) -> {{ m.type.py_type }}:
{# Transparent builtins are guaranteed to have `is_stack_only == True` #}
    # Call to __new__ bypasses __init__ constructor
    cdef {{ m.type.cy_type }} ret = {{ m.type.cy_type }}.__new__({{ m.type.cy_type }})
    ret._gd_data = self._gd_data.{{ m.name }}
    return ret

def set_{{ m.name }}(self, {{ m.type.cy_type }} val not None):
{# Transparent builtins are guaranteed to have `is_stack_only == True` #}
    self._gd_data.{{ m.name }} = val._gd_data

{%     endfor %}
{%   endif %}
{% endif %}
{% endmacro %}


{#########################################################################
 # Render method
 #########################################################################}

{% macro render_method(spec, m) %}
def {{ m.name }}(self, {% for arg in m.arguments %}{{ arg.type.cy_type }} {{ arg.name }}, {% endfor %}):  # -> {{ "None" if m.return_type.is_nil else m.return_type.py_type }}
{%   if m.contains_unsuported_types %}
    raise NotImplementedError
{%   else %}
{#  Return type #}
{%   if m.return_type.is_nil %}
{%   elif m.return_type.is_scalar %}
    cdef {{ m.return_type.cy_type }} ret = 0
{%   elif m.return_type.is_builtin %}
    # Call to __new__ bypasses __init__ constructor
    cdef {{ m.return_type.cy_type }} ret = {{ m.return_type.cy_type }}.__new__({{ m.return_type.cy_type }})
{%   endif %}
{#  Arguments #}
{%   if (m.arguments | length) != 0 %}
    cdef GDNativeTypePtr[{{ m.arguments | length }}] args = [
{%     for arg in m.arguments %}
{%       if arg.type.is_scalar %}
        &{{ arg.name }},
{%       else %}
        &{{ arg.name }}._gd_data,
{%       endif %}
{%     endfor %}
    ]
{%   endif %}
{#  Actual call ! #}
    __{{ spec.name }}_meth_{{ m.name }}(
{#      GDNativeTypePtr p_base #}
        &self._gd_data,
{#      const GDNativeTypePtr *p_args #}
        {{ "NULL" if (m.arguments | length) == 0 else "args" }},
{#      GDNativeTypePtr r_return #}
{%   if m.return_type.is_nil %}
        NULL,
{%   elif m.return_type.is_scalar %}
        &ret,
{%   elif m.return_type.is_builtin %}
        &ret._gd_data,
{%   endif %}
{#      int p_argument_count #}
        {{ m.arguments | length }},
    )
{%   if not m.return_type.is_nil %}
    return ret
{%   endif %}
{%   endif %}
{% endmacro %}


{#########################################################################
 # Render full class spec
 #########################################################################}

{% macro render_spec(spec) -%}

@cython.freelist(8)
@cython.final
cdef class {{ spec.name }}:
    # Constructors
    {{ render_constructors(spec) | indent }}

{% if spec.has_destructor %}
    # Destructor
    def __dealloc__({{ spec.name }} self):
        # /!\ if `__cinit__` is skipped, `_gd_data` must be initialized by
        # hand otherwise we will get a segfault here
        __{{ spec.name }}_destructor(&self._gd_data)
{% else %}
    # Destructor not needed
{% endif %}

    def __repr__(self):
        # TODO: finish me...
        # pythonscript_gdapi.variant_stringify(&self._gd_data)
        return "<{{ spec.name }}>"

{% if spec.constants %}
    # Constants

{% endif %}
{% for c in spec.constants %}
    {{ render_constant(spec, c) | indent }}
{% endfor %}

{% if spec.members %}
    # Members

{% endif %}
{% for m in spec.members %}
    {{ render_member(spec, m) | indent }}
{% endfor %}

{% if spec.methods %}
    # Methods

{% endif %}
{% for m in spec.methods %}
    {{ render_method(spec, m) | indent }}
{% endfor %}

{%- endmacro %}
