{% macro render_all_conversions() %}
cdef str _ENSURE_IS_GDANY_ERR_MSG = "Invalid value `{}`, expected IntoGDAny"
cdef str _ENSURE_IS_GDSTRING_ERR_MSG = "Invalid value `{}`, expected str or GDString"
cdef str _ENSURE_IS_NODEPATH_ERR_MSG = "Invalid value `{}`, expected be str or NodePath"


cdef bint gd_variant_supports_py_type(object pytype):
    if issubclass(pytype, GDObject):
        return True
    elif (
{% for builtin in api.builtins %}
        pytype == {{ builtin.cy_type }} or
{% endfor %}
        pytype == bool or
        pytype == int or
        pytype == float or
        pytype == type(None)
    ):
        return True
    else:
        return False


cdef object gd_to_py_type(GDNativeVariantType gdtype):
    if gdtype == GDNATIVE_VARIANT_TYPE_OBJECT:
        return GDObject
{% for builtin in api.builtins %}
    elif gdtype == {{ builtin.variant_type_name }}:
        return {{ builtin.cy_type }}
{% endfor %}
    elif gdtype == {{ api.bool_type.variant_type_name }}:
        return bool
    elif gdtype == {{ api.int_type.variant_type_name }}:
        return int
    elif gdtype == {{ api.float_type.variant_type_name }}:
        return float
    elif gdtype == {{ api.nil_type.variant_type_name }}:
        return None
    else:
        warn(f"No Python equivalent for Godot type `{gdtype}`")
        return None


cdef GDNativeVariantType py_to_gd_type(object pytype):
    if issubclass(pytype, GDObject):
        return GDNATIVE_VARIANT_TYPE_OBJECT
{% for builtin in api.builtins %}
    elif pytype == {{ builtin.cy_type }}:
        return {{ builtin.variant_type_name }}
{% endfor %}
    elif pytype == bool:
        return {{ api.bool_type.variant_type_name }}
    elif pytype == int:
        return {{ api.int_type.variant_type_name }}
    elif pytype == float:
        return {{ api.float_type.variant_type_name }}
    elif pytype == type(None):
        return {{ api.nil_type.variant_type_name }}
    else:
        warn(f"No Godot equivalent for Python type `{pytype}`")
        return GDNATIVE_VARIANT_TYPE_NIL


#########################################################################
# Gdoot Variant -> PyObject
#########################################################################


cdef object gd_variant_to_pyobj(const gd_variant_t *p_gdvar):
    # TODO: must do an ugly cast because autopxd2 ignores const qualifiers in the C headers
    cdef GDNativeVariantType gdtype = pythonscript_gdnative_interface.variant_get_type(<gd_variant_t *>p_gdvar)
    if gdtype == GDNATIVE_VARIANT_TYPE_OBJECT:
        raise NotImplementedError  # TODO
        # # TODO: This conversion relies on godot String and lookup into bindings
        # # modules, wouldn't it be better to create a `ObjectFromVariant` lazy
        # # class instead ?
        # return Object.cast_from_variant(p_gdvar)
    elif gdtype == {{ api.bool_type.variant_type_name }}:
        return {{ api.bool_type.c_name_prefix }}_from_variant(<gd_variant_t*>p_gdvar)
    elif gdtype == {{ api.int_type.variant_type_name }}:
        return {{ api.int_type.c_name_prefix }}_from_variant(<gd_variant_t*>p_gdvar)
    elif gdtype == {{ api.float_type.variant_type_name }}:
        return {{ api.float_type.c_name_prefix }}_from_variant(<gd_variant_t*>p_gdvar)
{% for builtin in api.builtins %}
    elif gdtype == {{ builtin.variant_type_name }}:
{%   if builtin.is_nil %}
        return None
{%   else %}
        return _gd_variant_to_pyobj_{{ builtin.cy_type }}(p_gdvar)
{%   endif %}
{% endfor %}
    elif gdtype == GDNATIVE_VARIANT_TYPE_NIL:
        return None
    else:
        warn(f"Unknown Godot Variant type `{gdtype}` (this should never happen !)")
        return None


{% for builtin in api.builtins if not builtin.is_nil %}
cdef inline object _gd_variant_to_pyobj_{{ builtin.cy_type }}(const gd_variant_t *p_gdvar):
{%   if builtin.cy_type == "bool" %}
    cdef {{ api.bool_type.cy_type }} ret = {{ builtin.c_name_prefix }}_from_variant(<gd_variant_t *>p_gdvar)
    return bool(ret)
{%   elif builtin.cy_type == "int" %}
    cdef {{ api.int_type.cy_type }} ret = {{ builtin.c_name_prefix }}_from_variant(<gd_variant_t *>p_gdvar)
    return ret
{%   elif builtin.cy_type == "float" %}
    cdef {{ api.float_type.cy_type }} ret = {{ builtin.c_name_prefix }}_from_variant(<gd_variant_t *>p_gdvar)
    return ret
{%   else %}
    cdef {{ builtin.cy_type }} ret = {{ builtin.cy_type }}.__new__({{ builtin.cy_type }})
    ret._gd_data = {{ builtin.c_name_prefix }}_from_variant(<gd_variant_t *>p_gdvar)
    return ret
{%   endif %}
{% endfor %}


#########################################################################
# PyObject -> Godot Variant
#########################################################################


cdef bint gd_variant_from_pyobj(object pyobj, gd_variant_t *p_gdvar):
    if pyobj is None:
        pythonscript_gdnative_interface.variant_new_nil(p_gdvar)
    elif isinstance(pyobj, GDObject):
        p_gdvar[0] = gd_object_into_variant((<GDObject>pyobj)._gd_ptr)
    elif isinstance(pyobj, bool):  # TODO: try/except on the gd_bool_into_variant is enough ?
        p_gdvar[0] = gd_bool_into_variant(pyobj)
    elif isinstance(pyobj, int):
        p_gdvar[0] = gd_int_into_variant(pyobj)
    elif isinstance(pyobj, float):
        p_gdvar[0] = gd_float_into_variant(pyobj)
    elif isinstance(pyobj, str):
        _gd_variant_from_pyobj_pystr(pyobj, p_gdvar)
{% for builtin in api.builtins if not builtin.is_scalar %}
    elif isinstance(pyobj, {{ builtin.cy_type }}):
        p_gdvar[0] = {{ builtin.c_name_prefix }}_into_variant(&(<{{ builtin.cy_type }}>pyobj)._gd_data)
{% endfor %}
    else:
        warn(f"Cannot convert `{type(pyobj)}` to Godot's Variant")
        pythonscript_gdnative_interface.variant_new_nil(p_gdvar)
        return False
    return True


cdef inline void _gd_variant_from_pyobj_pystr(object pyobj, gd_variant_t *p_gdvar):
    cdef gd_string_t gdstr = gd_string_from_unchecked_pystr(pyobj)
    p_gdvar[0] = gd_string_into_variant(&gdstr)
    # into conversion steals the ownership, so don't need to call `gd_string_del(gdstr)`
{% endmacro %}
