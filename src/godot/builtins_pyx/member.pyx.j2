{% macro render_transparent_builtin_scalar_property(m, name_prefix, access_prefix) -%}
@property
def {{ name_prefix }}{{ m.name }}(self):
    return {{ access_prefix }}.{{ m.name }}
@{{ name_prefix }}{{ m.name }}.setter
def {{ name_prefix }}{{ m.name }}(self, {{ m.type.cy_type }} val):
    {{ access_prefix }}.{{ m.name }} = val
{% endmacro %}


{% macro render_transparent_builtin_subtype_properties(m, name_prefix, access_prefix) -%}
{% for subm in m.type.builtin_spec.c_struct_members %}
{%   if subm.is_in_struct %}
{%     if subm.type.is_scalar %}
{{ render_transparent_builtin_scalar_property(subm, name_prefix, access_prefix) }}
{%     else %}
{{ render_transparent_builtin_subtype_properties(subm, "{}_{}".format(name_prefix, subm.name), "{}.{}".format(access_prefix, subm.name)) }}
{%     endif %}
{%   endif %}
{% endfor %}
{% endmacro %}


{% macro render_member(spec, m) %}
{% if not m.is_in_struct %}
{# Property unrelated to the builtin internal structure, must use Godot API method to access it #}
@property
def {{ m.name }}(self):
    return {{ spec.name }}.get_{{ m.name }}(self)
@{{ m.name }}.setter
def {{ m.name }}(self, {{ m.type.cy_type }} val{{ "" if m.type.is_scalar else " not None"}}):
    {{ spec.name }}.set_{{ m.name }}(self, val)
{% else %}
{# Property that is contains in the builtin C structure #}

{%   if m.type.is_scalar %}

{# Scalar type in the C structure (i.e. `Vector2.x`) #}
{{ render_transparent_builtin_scalar_property(m, "", "self._gd_data") }}

{%   else %}

{# Builtin type in the C structure (i.e. `Rect2.position` with position being a `Vector2`) #}
{# In GDScript doing `rect2.position.x = 42` modifies `rect2`, that means `rect2.position` #}
{# is a proxy object on the content of `rect2`, this is cumbersome to do in Python (and make #}
{# thing slower) so we replace this by property on the subtype members: `rect2.position_x` #}
{{ render_transparent_builtin_subtype_properties(m, "{}_".format(m.name), "self._gd_data.{}".format(m.name)) }}

{# Also expose the member, but as a functions so it's clearer this works on copies #}
{%     for subm in m.type.builtin_spec.c_struct_members %}
def get_{{ m.name }}(self):
{# Transparent builtins are guaranteed to have `is_stack_only == True` #}
    # Call to __new__ bypasses __init__ constructor
    cdef {{ m.type.cy_type }} ret = {{ m.type.cy_type }}.__new__({{ m.type.cy_type }})
    ret._gd_data = self._gd_data.{{ m.name }}
    return ret

def set_{{ m.name }}(self, {{ m.type.cy_type }} val not None):
{# Transparent builtins are guaranteed to have `is_stack_only == True` #}
    self._gd_data.{{ m.name }} = val._gd_data

{%     endfor %}
{%   endif %}
{% endif %}
{% endmacro %}
