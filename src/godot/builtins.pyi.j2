# /!\ Autogenerated code, modifications will be lost /!\
# see `scripts/generate_tmpl.py`

from collections.abc import Mapping, Sequence
from enum import Enum

from .classes import GDObject


# GDany represent any type that can be send to / retreive from Godot
# (i.e. it is all the types than can be converted to a Godot Variant)
GDAny = (
    None |
    GDObject |
{% for spec in api["builtins"] if not spec.is_nil %}
    {{ spec.name }}{{ "" if loop.last else " |" }}
{% endfor %}
)
# For convenience, we allow using Python types where Godot ones are needed.
# This allows for instance to do `my_node.do("foo")` instead of the infamous
# `my_node.do(GDString("foo"))`.
# Of course keep in mind this involves types conversion and is slower than only working
# with Godot types (for instance to speed up the previous example, `GDString("foo")`
# should be instantiated once and reused between `my_node.do(...)` calls)
IntoGDAny = GDAny | str | Mapping[IntoGDAny, IntoGDAny] | Sequence[IntoGDAny]

{%- macro render_arg(arg) -%}
{{ "{}: ".format(arg.name) }}
{%- if arg.type.py_type == "GDString" %}
GDString | str
{%- elif arg.type.py_type == "StringName" %}
StringName | str
{%- elif arg.type.py_type == "NodePath" %}
NodePath | str
{%- elif arg.type.py_type == "GDList" %}
GDList | Sequence[IntoGDAny]
{%- elif arg.type.py_type == "GDDictionary" %}
GDDictionary | Mapping[IntoGDAny, IntoGDAny]
{%- elif arg.type.py_type == "GDAny" %}
IntoGDAny
{%- else %}
{{ arg.type.py_type }}
{%- endif %}
{%- if arg.default_value is not none %}
 = {{ arg.default_value.py_value }}
{%- endif %}
{%- endmacro %}


##############################################################################
#                              Global constants                              #
##############################################################################


{% for spec in api["global_constants"] %}
{{ spec.name }}: {{ spec.py_type }}
{% endfor %}


##############################################################################
#                                Global enums                                #
##############################################################################
{% for spec in api["global_enums"] %}


class {{ spec.name }}(Enum):
{%   for key in spec.values.keys() %}
    {{ key }}: int
{%   endfor %}
{% endfor %}


##############################################################################
#                              Utility functions                             #
##############################################################################


{% for spec in api["utility_functions"] %}
def {{ spec.name }}(
{%-     for arg in spec.arguments -%}
    {{ render_arg(arg) }}
{%-     if not loop.last -%}, {% endif %}
{%     endfor -%}
) -> {{ "None" if spec.return_type.is_nil else spec.return_type.py_type }}: ...
{% endfor %}


##############################################################################
#                                  Builtins                                  #
##############################################################################
{% for spec in api["builtins"] if not spec.is_scalar %}
{% for e in spec.enums %}


class {{ e.name }}(Enum):
{%   for key in e.values.keys() %}
    {{ key }}: int
{%   endfor %}
{% endfor %}


class {{spec.name}}:
{%   for c in spec.constructors %}
{#  TODO: merged together the constructors ! #}
    def __init__(self{% for a in c.arguments %}, {{ render_arg(a) }}{% endfor %}): ...
{%   endfor %}
{%   if spec.members %}

    def clone(self) -> {{ spec.name }}: ...

    # Members
{%   endif %}
{%   for m in spec.members %}
    {{m.name}}: {{ m.type.py_type }}
{%   endfor %}
{%   if spec.methods %}

    # Methods
{%   endif %}
{%   for m in spec.methods %}
    def {{m.name}}(self{% for a in m.arguments %}, {{ render_arg(a) }}{% endfor %}) -> {{ "None" if m.return_type.is_nil else m.return_type.py_type }}: ...
{%   endfor %}
{%   if spec.constants %}

    # Constants
{%   endif %}
{%   for c in spec.constants %}
    {{c.name}}: {{c.type.py_type}}
{%   endfor %}
{% endfor %}
