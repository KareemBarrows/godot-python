{# from warnings import warn

from .gdnative_interface cimport *
from ..classes cimport GDObject


cdef bint is_pytype_compatible_with_gdvariant(object pytype):
    if issubclass(pytype, GDObject):
        return True
    elif (
{% for builtin in api.builtins %}
        pytype == {{ builtin.name }} or
{% endfor %}
        pytype == bool or
        pytype == int or
        pytype == float or
        pytype == type(None)
    ):
        return True
    else:
        return False


cdef object gdtype_to_pytype(GDNativeVariantType gdtype):
    if gdtype == GDNATIVE_VARIANT_TYPE_OBJECT:
        return GDObject
{% for builtin in api.builtins %}
    elif gdtype == {{ builtin.variant_type_name }}:
        return {{ builtin.cy_type }}
{% endfor %}
    elif gdtype == {{ api.bool_type.variant_type_name }}:
        return bool
    elif gdtype == {{ api.int_type.variant_type_name }}:
        return int
    elif gdtype == {{ api.float_type.variant_type_name }}:
        return float
    elif gdtype == {{ api.nil_type.variant_type_name }}:
        return None
    else:
        warn(f"No Python equivalent for Godot type `{gdtype}`")
        return None


cdef GDNativeVariantType pytype_to_gdtype(object pytype):
    if issubclass(pytype, GDObject):
        return GDNATIVE_VARIANT_TYPE_OBJECT
{% for builtin in api.builtins %}
    elif pytype == {{ builtin.name }}:
        return {{ builtin.variant_type_name }}
{% endfor %}
    elif pytype == bool:
        return {{ api.bool_type.variant_type_name }}
    elif pytype == int:
        return {{ api.int_type.variant_type_name }}
    elif pytype == float:
        return {{ api.float_type.variant_type_name }}
    elif pytype == type(None):
        return {{ api.nil_type.variant_type_name }}
    else:
        warn(f"No Godot equivalent for Python type `{pytype}`")
        return GDNATIVE_VARIANT_TYPE_NIL


#########################################################################
# Gdoot Variant -> PyObject
#########################################################################


cdef object gdvariant_to_pyobject(const gd_variant_t *p_gdvar):
    # TODO: must do an ugly cast because autopxd2 ignores const qualifiers in the C headers
    cdef GDNativeVariantType gdtype = pythonscript_gdnative_interface.variant_get_type(<gd_variant_t *>p_gdvar)
    if gdtype == GDNATIVE_VARIANT_TYPE_OBJECT:
        raise NotImplementedError  # TODO
        # # TODO: This conversion relies on godot String and lookup into bindings
        # # modules, wouldn't it be better to create a `ObjectFromVariant` lazy
        # # class instead ?
        # return Object.cast_from_variant(p_gdvar)
{% for builtin in api.builtins %}
    elif gdtype == {{ builtin.variant_type_name }}:
{%   if builtin.is_nil %}
        return None
{%   else %}
        return _gdvariant_to_pyobject_{{ builtin.name }}(p_gdvar)
{%   endif %}
{% endfor %}
    else:
        warn(f"Unknown Godot Variant type `{gdtype}` (this should never happen !)")
        return None


{% for builtin in api.builtins if not builtin.is_nil %}
cdef inline object _gdvariant_to_pyobject_{{ builtin.name }}(const gd_variant_t *p_gdvar):
{%   if builtin.name == "bool" %}
    cdef {{ api.bool_builtin.cy_type }} ret
    __{{ builtin.name }}_from_variant(&ret, <gd_variant_t *>p_gdvar)
    return bool(ret)
{%   elif builtin.name == "int" %}
    cdef {{ api.int_builtin.cy_type }} ret
    __{{ builtin.name }}_from_variant(&ret, <gd_variant_t *>p_gdvar)
    return ret
{%   elif builtin.name == "float" %}
    cdef {{ api.float_builtin.cy_type }} ret
    __{{ builtin.name }}_from_variant(&ret, <gd_variant_t *>p_gdvar)
    return ret
{%   else %}
    cdef {{ builtin.name }} ret = {{ builtin.name }}.__new__({{ builtin.name }})
    __{{ builtin.name }}_from_variant(&ret._gd_data, <gd_variant_t *>p_gdvar)
    return ret
{%   endif %}
{% endfor %}


#########################################################################
# PyObject -> Godot Variant
#########################################################################


cdef bint pyobject_to_gdvariant(object pyobj, gd_variant_t *p_gdvar):
    if pyobj is None:
        pythonscript_gdnative_interface.variant_new_nil(p_gdvar)
    elif isinstance(pyobj, GDObject):
        __GDObject_into_variant(p_gdvar, (<GDObject>pyobj)._gd_ptr)
    elif isinstance(pyobj, bool):
        _pyobject_to_gdvariant_bool(pyobj, p_gdvar)
    elif isinstance(pyobj, int):
        _pyobject_to_gdvariant_int(pyobj, p_gdvar)
    elif isinstance(pyobj, float):
        _pyobject_to_gdvariant_float(pyobj, p_gdvar)
    elif isinstance(pyobj, str):
        _pyobject_to_gdvariant_pystr(pyobj, p_gdvar)
{% for builtin in api.builtins if not builtin.is_scalar %}
    elif isinstance(pyobj, {{ builtin.name }}):
        __{{ builtin.name }}_into_variant(p_gdvar, &(<{{ builtin.name }}>pyobj)._gd_data)
{% endfor %}
    else:
        warn(f"Cannot convert `{type(pyobj)}` to Godot's Variant")
        pythonscript_gdnative_interface.variant_new_nil(p_gdvar)
        return False
    return True


cdef inline void _pyobject_to_gdvariant_bool({{ api.bool_builtin.cy_type }} val, gd_variant_t *p_gdvar):
    __bool_into_variant(p_gdvar, &val)


cdef inline void _pyobject_to_gdvariant_float({{ api.float_builtin.cy_type }} val, gd_variant_t *p_gdvar):
    __float_into_variant(p_gdvar, &val)


cdef inline void _pyobject_to_gdvariant_int({{ api.int_builtin.cy_type }} val, gd_variant_t *p_gdvar):
    __int_into_variant(p_gdvar, &val)


cdef inline void _pyobject_to_gdvariant_pystr(object pyobj, gd_variant_t *p_gdvar):
    cdef gd_string_t gdstr = gd_string_from_unchecked_pystr(pyobj)
    __GDString_into_variant(p_gdvar, &gdstr)
    # into conversion steals the ownership, so don't need to call `gd_string_del(gdstr)` #}
