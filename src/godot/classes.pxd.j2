# /!\ Autogenerated code, modifications will be lost /!\
# see `scripts/generate_tmpl.py`

cimport cython

from .hazmat.gdapi cimport pythonscript_gdapi
from .hazmat.gdnative_interface cimport GDNativeObjectPtr


cdef inline gdobject_free(GDObject obj):
    pythonscript_gdapi.object_destroy(obj._gd_ptr)
{% for spec in api["classes"] %}


{# Cannot put this from_ptr as static method given cdef inline requires a final #}
{# method (i.e. it cannot be overwritten by child class) #}
cdef inline {{ spec.name | lower }}_from_ptr(GDNativeObjectPtr ptr):
    # Call to __new__ bypasses __init__ constructor
    cdef {{ spec.name }} wrapper = {{ spec.name }}.__new__({{ spec.name }})
    wrapper._gd_ptr = ptr
{%   if spec.is_refcounted %}
    # Note we steal the reference from the caller given we
    # don't call `Reference.reference` here
{%   endif %}
    return wrapper


cdef class {{spec.name}}({{ spec.inherits or "" }}):
{%   if spec.inherits is none %}
    cdef GDNativeObjectPtr _gd_ptr

    {# @staticmethod
    cdef inline GDObject cast_from_variant(const godot_variant *p_gdvar)

    @staticmethod
    cdef inline GDObject cast_from_ptr(GDNativeObjectPtr *ptr):
        self._gd_ptr = ptr #}
{%   else %}
    pass
{%   endif %}
{% endfor %}
