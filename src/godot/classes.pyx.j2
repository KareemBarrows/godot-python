cimport cython

from .hazmat.gdapi cimport *
from .builtins cimport *
{% for klass in api.classes %}


cdef class {{ klass.cy_type }}({{ klass.inherits.cy_type if klass.inherits else "" }}):
{%   if klass.inherits is none %}

    {# @staticmethod
    cpdef inline {{ klass.cy_type}} new():
        raise NotImplementedError("TODO :'(") #}

    def free(self):
        pythonscript_gdnative_interface.object_destroy(self._gd_ptr)
        self._gd_ptr = NULL

    def __init__(self):
        raise RuntimeError(
            f"Use `new()` method to instantiate non-refcounted Godot object (and don't forget to free it !)"
        )

    def __repr__(self):
        return f"<{type(self).__name__} wrapper on 0x{<size_t>self._gd_ptr:x}>"
{%   else %}
    pass
{% endif %}
{% endfor %}


cdef _load_singleton(name):
    cdef GDObject gdobj = GDObject.__new__(GDObject)
    gdobj._gd_ptr = pythonscript_gdnative_interface.global_get_singleton(name)
{% for singleton in api.singletons %}
    cdef {{ singleton.type.py_type }} singleton_{{ singleton.name }} = {{ singleton.type.py_type }}.__new__({{ singleton.type.py_type }})
    singleton_{{ singleton.name }}._gd_ptr = pythonscript_gdnative_interface.global_get_singleton("{{ singleton.original_name }}")
    globals()["{{ singleton.name }}"] = singleton_{{ singleton.name }}
{% endfor %}


cdef object _load_class(str name):
    cdef StringName gdname = StringName(name)

    # Load our good friend ClassDB
    cdef GDNativeObjectPtr classdb = pythonscript_gdnative_interface.global_get_singleton("ClassDB")

    if not _object_call(classdb, "class_exists", [gdname]):
        raise RuntimeError(f"Class `{name}` doesn't exist in Godot !")

    gdparent = _object_call(classdb, "get_parent_class", [gdname])
    parent = str(gdparent)
    if parent:
        parent_cls = _load_class(parent)
        bases = (parent_cls, )
    else:
        bases = ()

    meths = _object_call(classdb, "class_get_method_list", [gdname])
    properties = _object_call(classdb, "class_get_property_list", [gdname])
    signals = _object_call(classdb, "class_get_signal_list", [gdname])

    # TODO

    attrs = {}

    return type(name, bases, attrs)


cdef object _object_call(GDNativeObjectPtr obj, str meth, args):
    cdef gd_variant_t ret
    cdef GDNativeCallError call_error

    cdef GDNativeObjectPtr classdb = pythonscript_gdnative_interface.global_get_singleton("ClassDB")
    cdef GDNativeMethodBindPtr Object_call = pythonscript_gdnative_interface.classdb_get_method_bind("Object", "call", {{ api.get_class_meth_hash("Object", "call") }})

    cdef GDNativeInt args_with_meth_len = len(args) + 1
    if args_with_meth_len > 9:
        # TODO: handle this
        pythonscript_gdnative_interface.print_error("more than 8 params is not supported !", "_object_call", "", 0)
        return None
    cdef gd_variant_t[9] variant_args
    cdef (gd_variant_t*)[9] variant_args_ptrs
    for i in range(args_with_meth_len):
        variant_args_ptrs[i] = &variant_args[i]

    cdef gd_string_t meth_gdstr = gd_string_from_unchecked_pystr(meth)
    cdef gd_string_name_t meth_gdstrname = gd_string_name_new_from_string(&meth_gdstr)
    gd_string_del(&meth_gdstr)
    variant_args[0] = gd_string_name_into_variant(&meth_gdstrname)
    # Into conversion steals the owneship, so no need to delete meth_gdstrname

    for i, arg in enumerate(args, 1):
        # TODO: check return value
        gd_variant_from_pyobj(arg, &variant_args[i])

    pythonscript_gdnative_interface.object_method_bind_call(
        Object_call,
        classdb,
        <GDNativeVariantPtr *>&variant_args_ptrs,
        args_with_meth_len,
        &ret,
        &call_error,
    )
    # TODO: improve ret error check
    if call_error.error != GDNATIVE_CALL_OK:
        raise RuntimeError(f"Error in call: {call_error.error}")
    for i in range(args_with_meth_len):
        gd_variant_del(&variant_args[i])

    try:
        return gd_variant_to_pyobj(&ret)
    finally:
        gd_variant_del(&ret)
