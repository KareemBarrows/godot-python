cimport cython

from .hazmat.gdapi cimport *
from .builtins cimport *

cdef class BaseGDObject:
    def free(self):
        pythonscript_gdnative_interface.object_destroy(self._gd_ptr)
        self._gd_ptr = NULL

    def __init__(self):
        raise RuntimeError(
            f"Use `new()` method to instantiate non-refcounted Godot object (and don't forget to free it !)"
        )

    def __repr__(self):
        return f"<{type(self).__name__} wrapper on 0x{<size_t>self._gd_ptr:x}>"

    @staticmethod
    cdef BaseGDObject from_ptr(GDNativeObjectPtr ptr):
        # Call to __new__ bypasses __init__ constructor
        cdef BaseGDObject wrapper = BaseGDObject.__new__(BaseGDObject)
        wrapper._gd_ptr = ptr
        return wrapper

{# {% for klass in api.classes %} #}
{#  #}
{#  #}
{# cdef class {{ klass.cy_type }}({{ klass.inherits.cy_type if klass.inherits else "" }}): #}
{# {%   if klass.inherits is none %} #}
{#  #}
{#     {# @staticmethod #}
{#     cpdef inline {{ klass.cy_type}} new(): #}
{#         raise NotImplementedError("TODO :'(") #} #}
{#  #}
{#     def free(self): #}
{#         pythonscript_gdnative_interface.object_destroy(self._gd_ptr) #}
{#         self._gd_ptr = NULL #}
{#  #}
{#     def __init__(self): #}
{#         raise RuntimeError( #}
{#             f"Use `new()` method to instantiate non-refcounted Godot object (and don't forget to free it !)" #}
{#         ) #}
{#  #}
{#     def __repr__(self): #}
{#         return f"<{type(self).__name__} wrapper on 0x{<size_t>self._gd_ptr:x}>" #}
{# {%   else %} #}
{#     pass #}
{# {% endif %} #}
{# {% endfor %} #}


cdef object _load_singleton(str name):
    cdef object cls = _load_class(name)
{# cdef GDNativeObjectPtr gdobj = pythonscript_gdnative_interface.global_get_singleton(&(<StringName>cls._gd_name)._gd_data) #}
    cdef GDNativeObjectPtr gdobj = pythonscript_gdnative_interface.global_get_singleton(name.encode())
    cdef object obj = BaseGDObject.from_ptr(gdobj)
    obj.__class__ = cls
    return obj
{# {% for singleton in api.singletons %}
    cdef {{ singleton.type.py_type }} singleton_{{ singleton.name }} = {{ singleton.type.py_type }}.__new__({{ singleton.type.py_type }})
    singleton_{{ singleton.name }}._gd_ptr = pythonscript_gdnative_interface.global_get_singleton("{{ singleton.original_name }}")
    globals()["{{ singleton.name }}"] = singleton_{{ singleton.name }}
{% endfor %} #}


cdef object _property_getter(object obj, str name):
    return _object_call((<GDObject>obj)._gd_ptr, "get", [name])


cdef void _property_setter(object obj, str name, object value):
    _object_call((<GDObject>obj)._gd_ptr, "set", [name, value])


cdef object _meth_call(object obj, str name, list args):
    return _object_call((<GDObject>obj)._gd_ptr, "call", [name, *args])


cdef object _load_class(str name):
    cdef StringName gdname = StringName(name)

    # Load our good friend ClassDB
    cdef GDNativeObjectPtr classdb = pythonscript_gdnative_interface.global_get_singleton("ClassDB")

    if not _object_call(classdb, "class_exists", [gdname]):
        raise RuntimeError(f"Class `{name}` doesn't exist in Godot !")

    print("loading", name)
    gdparent = _object_call(classdb, "get_parent_class", [gdname])
    parent = str(gdparent)
    if parent:
        parent_cls = _load_class(parent)
        bases = (parent_cls, )
    else:
        bases = (BaseGDObject, )

    attrs = {"_gd_name", gdname}

    def _generate_method(spec):
        methname = spec["name"]
        def _meth(self, *args):
            print(f"CALL {methname} {args!r}")
            return _meth_call(self, methname, args)

    meths = _object_call(classdb, "class_get_method_list", [gdname])
    for meth in meths:
        attrs[meth["name"]] = _generate_method(meth)

    def _generate_property(spec):
        propname = spec["name"]
        @property
        def _property(self):
            print(f"GET {propname}")
            return _property_getter(self, propname)
        _property.__name__ = spec["name"]
        @_property.setter
        def _property(self, value):
            print(f"GET {propname} {value!r}")
            _property_setter(self, propname, value)
        _property.__name__ = spec["name"]
        return _property

    properties = _object_call(classdb, "class_get_property_list", [gdname])
    for prop in properties:
        attrs[prop["name"]] = _generate_property(prop)

    signals = _object_call(classdb, "class_get_signal_list", [gdname])
    # TODO

    return type(name, bases, attrs)


cdef object _object_call(GDNativeObjectPtr obj, str meth, args):
    cdef gd_variant_t ret
    cdef GDNativeCallError call_error

    cdef GDNativeObjectPtr classdb = pythonscript_gdnative_interface.global_get_singleton("ClassDB")
    cdef GDNativeMethodBindPtr Object_call = pythonscript_gdnative_interface.classdb_get_method_bind("Object", "call", {{ api.get_class_meth_hash("Object", "call") }})

    cdef GDNativeInt args_with_meth_len = len(args) + 1
    if args_with_meth_len > 9:
        # TODO: handle this
        pythonscript_gdnative_interface.print_error("more than 8 params is not supported !", "_object_call", "", 0)
        return None
    cdef gd_variant_t[9] variant_args
    cdef (gd_variant_t*)[9] variant_args_ptrs
    for i in range(args_with_meth_len):
        variant_args_ptrs[i] = &variant_args[i]

    cdef gd_string_t meth_gdstr = gd_string_from_unchecked_pystr(meth)
    cdef gd_string_name_t meth_gdstrname = gd_string_name_new_from_string(&meth_gdstr)
    gd_string_del(&meth_gdstr)
    variant_args[0] = gd_string_name_into_variant(&meth_gdstrname)
    # Into conversion steals the owneship, so no need to delete meth_gdstrname

    for i, arg in enumerate(args, 1):
        # TODO: check return value
        gd_variant_from_pyobj(arg, &variant_args[i])

    pythonscript_gdnative_interface.object_method_bind_call(
        Object_call,
        classdb,
        <GDNativeVariantPtr *>&variant_args_ptrs,
        args_with_meth_len,
        &ret,
        &call_error,
    )
    # TODO: improve ret error check
    if call_error.error != GDNATIVE_CALL_OK:
        raise RuntimeError(f"Error in call: {call_error.error}")
    for i in range(args_with_meth_len):
        gd_variant_del(&variant_args[i])

    return gd_variant_steal_into_pyobj(&ret)
    # No need to destroy ret given the conversion has stolen ownership on data !
