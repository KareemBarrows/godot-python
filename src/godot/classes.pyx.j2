# /!\ Autogenerated code, modifications will be lost /!\
# see `scripts/generate_tmpl.py`

cimport cython

from .hazmat.gdapi cimport *
from .builtins cimport *
{% for spec in api["classes"] %}


cdef class {{ spec.name }}({{ spec.inherits or "" }}):
{%   if spec.inherits is none %}

    {# @staticmethod
    cpdef inline {{ spec.name}} new():
        raise NotImplementedError("TODO :'(") #}

    def free(self):
        pythonscript_gdapi.object_destroy(self._gd_ptr)
        self._gd_ptr = NULL

    def __init__(self):
        raise RuntimeError(
            f"Use `new()` method to instantiate non-refcounted Godot object (and don't forget to free it !)"
        )

    def __repr__(self):
        return f"<{type(self).__name__} wrapper on 0x{<size_t>self._gd_ptr:x}>"
{%   else %}
    pass
{% endif %}
{% endfor %}


cdef _load_singleton(name):
    cdef GDObject gdobj = GDObject.__new__(GDObject)
    gdobj._gd_ptr = pythonscript_gdapi.global_get_singleton(name)
{% for spec in api["singletons"] %}
    cdef {{ spec.type.py_type }} singleton_{{ spec.name }} = {{ spec.type.py_type }}.__new__({{ spec.type.py_type }})
    singleton_{{ spec.name }}._gd_ptr = pythonscript_gdapi.global_get_singleton("{{ spec.original_name }}")
    globals()["{{ spec.name }}"] = singleton_{{ spec.name }}
{% endfor %}


cdef object _load_class(str name):
    # Load our good friend ClassDB
    cdef GDNativeObjectPtr classdb = pythonscript_gdapi.global_get_singleton("ClassDB")

    if not _object_call(classdb, "class_exists", [name]):
        raise RuntimeError(f"Class `{name}` doesn't exist in Godot !")

    parent = _object_call(classdb, "get_parent_class", [name])
    if parent:
        parent_cls = _load_class(parent)
        bases = (parent_cls, )
    else:
        bases = ()

    meths = _object_call(classdb, "class_get_method_list", [name])
    properties = _object_call(classdb, "class_get_property_list", [name])
    signals = _object_call(classdb, "class_get_signal_list", [name])

    # TODO

    attrs = {}

    return type(name, bases, attrs)


cdef object _object_call(GDNativeObjectPtr obj, str meth, args):
    cdef gd_variant_t ret
    cdef GDNativeCallError call_error

    cdef GDNativeObjectPtr classdb = pythonscript_gdapi.global_get_singleton("ClassDB")
    cdef GDNativeMethodBindPtr Object_call = pythonscript_gdapi.classdb_get_method_bind("Object", "call", {{ api.get_class_meth_hash("Object", "call") }})

    cdef GDNativeInt args_with_meth_len = len(args) + 1
    if args_with_meth_len > 9:
        # TODO: handle this
        pythonscript_gdapi.print_error("more than 8 params is not supported !", "_object_call", "", 0)
        return None
    cdef gd_variant_t[9] variant_args
    cdef (gd_variant_t*)[9] variant_args_ptrs
    for i in range(args_with_meth_len):
        variant_args_ptrs[i] = &variant_args[i]

    cdef gd_string_t meth_gdstr = gdstring_from_unchecked_pystr(meth)
    cdef gd_string_name_t meth_gdstrname = gd_string_name_new_from_string(&meth_gdstr)
    gd_string_del(&meth_gdstr)
    variant_args[0] = gd_string_name_into_variant(&meth_gdstrname)
    # Into conversion steals the owneship, so no need to delete meth_gdstrname

    for i, arg in enumerate(args, 1):
        # TODO: check return value
        pyobject_to_gdvariant(arg, &variant_args[i])

    pythonscript_gdapi.object_method_bind_call(
        Object_call,
        classdb,
        <GDNativeVariantPtr *>&variant_args_ptrs,
        args_with_meth_len,
        &ret,
        &call_error,  # TODO: check call_error
    )
    pythonscript_gdapi.print_error("after call", "<function>", "<file>", 0)
    for i in range(args_with_meth_len):
        gd_variant_del(&variant_args[i])

    try:
        gd_print(&ret, 1)
        return gdvariant_to_pyobject(&ret)
    finally:
        gd_variant_del(&ret)
