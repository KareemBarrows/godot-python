{%- from 'builtins.macros.pxd.j2' import render_method -%}
cimport cython

cdef extern from "Python.h":
    const char* PyUnicode_AsUTF8AndSize(object, size_t*)
    object PyUnicode_DecodeUTF32(const char *s, size_t size, const char *errors, int *byteorder)

from .hazmat.gdapi cimport *


cdef inline GDString ensure_is_gdstring(object gdstring_or_pystr):
    cdef GDString gdstring_converted
    try:
        return <GDString?>gdstring_or_pystr
    except TypeError:
        try:
            return GDString(gdstring_or_pystr)
        except TypeError:
            raise TypeError(f"Invalid value {gdstring_or_pystr!r}, must be str or GDString")


cdef inline NodePath ensure_is_nodepath(object nodepath_or_pystr):
    cdef NodePath NodePath_converted
    try:
        return <NodePath?>nodepath_or_pystr
    except TypeError:
        try:
            return NodePath(nodepath_or_pystr)
        except TypeError:
            raise TypeError(f"Invalid value {nodepath_or_pystr!r}, must be str or NodePath")
{% for spec in api["builtins"] if not spec.is_scalar %}


@cython.freelist(8)
@cython.final
cdef class {{ spec.name }}:
    cdef {{ spec.c_struct_name }} _gd_data

    @staticmethod
    cdef inline {{ spec.name }} new():
        # Call to __new__ bypasses __init__ constructor
        cdef {{ spec.name }} ret = {{ spec.name }}.__new__({{ spec.name }})
        __{{ spec.name }}_constructor_0(&ret._gd_data, NULL)
        return ret
{% if spec.name == "GDString" %}
    cdef inline gd_string_t to_pystr(self):
        return gdstring_to_pystr(&self._gd_data)
{% endif %}
{% for m in spec.methods %}
    {{ render_method(spec, m) | indent }}
{% endfor %}
{% endfor %}
